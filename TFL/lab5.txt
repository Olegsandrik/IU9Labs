Что такое счетчиковые машины в теории формальных языков
________________________________________________________________
Для начала определим машину Тьюринга — это абстрактная вычислительная модель,
предложенная британским математиком Аланом Тьюрингом в 1936 году. Она служит основой 
для теории вычислений и помогает понять, что такое алгоритмы и вычислимые функции.

Машина Тьюринга состоит из следующих основных компонентов:

Лента: бесконечная лента, разделенная на ячейки, на каждой из которых может находиться 
символ из конечного алфавита (например, 0 и 1). Лента служит как память для хранения данных.

Головка: устройство, которое может перемещаться по ленте влево и вправо. 
Головка считывает символ из текущей ячейки и может записывать новый символ вместо него.

Состояние: машина имеет конечное количество состояний, одно из которых является начальным, 
а одно или несколько — конечными (или принимающими). Состояние определяет, какие действия 
должна выполнять машина в зависимости от текущего символа на ленте.

Правила перехода: набор правил, которые определяют, что делать машине в зависимости от 
текущего состояния и символа, считываемого головкой. Правила могут включать запись нового 
символа, перемещение головки и переход в новое состояние.

Машина Тьюринга может выполнять любые вычисления, которые могут быть описаны алгоритмически, 
и считается эквивалентной современным компьютерам в плане вычислительных возможностей. 
Она также используется для формулирования понятий вычислимости и сложности в теории вычислений.

Далее определим мультистековые машины Тьюринга — 
это обобщение стандартных машин Тьюринга, которые используют несколько стеков.

Стековая структура: 
В отличие от обычной машины Тьюринга, которая имеет одну ленту с возможностью чтения и записи, помимо ленты
мультистековая машина имеет несколько стеков. Кроме того в конфигурации МТ будут состояния всех стеков.

Переходы: 
Переходы в мультистековых машинах зависят от текущего состояния, считываемого символа с ленты 
(если имеется) и верхних элементов стеков. Это позволяет машине принимать более сложные решения.

Счетчиковая машина - это машина, которая рассматриваться как мультистековая машина со
следующими ограничениями:
    а) есть только два магазинных символа, Z0 (маркер дна) и X;
    б) вначале Z0 находится в каждом магазине;
    в) Z0 можно заменить только цепочкой вида Xi
    Z0 для некоторого i ≥ 0;
    г) X можно заменить только цепочкой вида Xi
    для некоторого i ≥ 0. Таким образом, Z0 встречается только на дне каждого магазина, а все остальные символы 
    (если есть) — это символы X.

Переходы: переход счетчиковой машины зависит от ее состояния, входного
символа и того, какие из счетчиков являются нулевыми. 


Свойства счетчиковой машины:
    1) Каждый язык, допускаемый счетчиковой машиной, рекурсивно перечислим. 
    Причина в том, что счетчиковые машины являются частным случаем магазинных, а
    магазинные — частным случаем многоленточных машин Тьюринга, которые по
    теореме о том, что каждый язык, допускаемый многоленточной МТ, рекурсивно перечислим,
    допускают только рекурсивно перечислимые языки.
    2) Каждый язык, допускаемый односчетчиковой машиной, является КС-языком.
================================================================
Что такое машина Тьюринга с полиномиальным пространством
________________________________________________________________
Машина Тьюринга (МТ) с полиномиальным ограничением пространства - частный случай МТ, где 
ресурсы ограничены полиномиально относительно входных данных. 
Существует некоторый полином p(n), для которого, имея вход w длиной n, машина Тьюринга
не посещает более p(n) клеток ленты. Можно считать, что лента
является односторонней, а МТ не сдвигается влево от начала входа.
Класс языков PSPACE  (polynomial space — полиномиальное пространство) определяется как
множество языков L(M) детерминированных МТ M с полиномиально ограниченным пространством. 
Определим также класс NPSPACE (nondeterministic polynomial space — недетерминированное полиномиальное
пространство) как множество языков L(M) недетерминированных МТ M с полиномиально ограниченным 
пространством. 
Теорема: NPSPACE = PSPACE 
Теорема: Если M — МТ с полиномиально ограниченным пространством, а
p(n) — полиномиальный предел ее пространства, то существует константа c, при которой
M, допуская свой вход w длиной n, делает это в пределах c^(1+p(n)) переходов.
Теорема: Если L — язык из PSPACE (NPSPACE), то L допускается детерминированной
(недетерминированной) МТ с полиномиально ограниченным пространством, которая
для некоторого полинома q(n) и константы c останавливается после не более чем c^q(n)
переходов.
================================================================
Что такое машина Тьюринга с использованием рандомизации, ее язык
________________________________________________________________
Для начала используем вариант многоленточной машины Тьюринга (частного случая МТ). 
Первая лента содержит вход. Вторая лента также начинается непустыми клетками 
(случайные биты, она содержит символы 0 и 1, выбранные с вероятностью 1/2). 
Вторая лента называется случайной лентой. Третья и последующие, если используются, 
вначале пусты и при необходимости выступают как рабочие. Данный вариант МТ называется
рандомизированной машиной Тьюринга или машина Тьюринга с использованием рандомизации.

Пример использования:
Рандомизированную версию быстрой сортировки можно реализовать с помощью МТ. 
Важным шагом является следующий рекурсивный процесс. Предположим, что подсписок сохранен 
в последовательных клетках входной ленты и выделен маркерами с обоих концов. В подсписке 
выбирается ведущий элемент, и подсписок делится на нижний и верхний подподсписки. 
Рандомизированная МТ выполняет такие действия:

    1. Пусть разделяемый подсписок имеет длину m. Используем до log2 m новых случайных битов 
    на второй ленте, чтобы выбрать случайное число между 1 и m; m-й элемент подсписка становится 
    ведущим. Отметим, что, возможно, вероятности выбора чисел от 1 до m не равны, поскольку m 
    может не быть степенью 2. Однако, если взять, например, ⎡2 log2 m⎤ битов с ленты 2, 
    рассмотреть их как число в диапазоне от 0 до m^2, взять остаток от деления на m и прибавить 1, 
    то все числа от 1 до m будут иметь вероятность, достаточно близкую к 1/m, 
    чтобы быстрая сортировка выполнялась корректно.
    2. Поместить ведущий элемент на ленту 3.

    3. Просмотреть список, выделенный на ленте 1, копируя элементы, которые не больше
    ведущего, на ленту 4.

    4. Снова просмотреть подсписок на ленте 1, копируя элементы, которые больше ведущего, 
    на ленту 5.

    5. Скопировать ленты 4 и затем 5 в пространство на ленте 1,
    ранее занятое выделенным подсписком. Поместить маркер между двумя подподсписками.
    
    6. Если подподсписки (хотя бы один из них) содержат более одного элемента, 
    рекурсивно отсортировать их по этому же алгоритму.

Заметим, что данная реализация быстрой сортировки требует O(n log n) времени, хотя
вычислительным устройством является МТ, а не обычный компьютер.

Замечание: Рандомизированная машина Тьюринга может не допускать никакой язык.  Проблема в том,
что при анализе действий рандомизированной МТ M со входом w приходится рассматривать 
все возможные случайные последовательности на второй ленте. Вполне возможно, что МТ 
допускает при одних случайных последовательностях, но отвергает при других; в действительности, 
если рандомизированная МТ должна делать что-то более эффективно, чем детерминированная МТ, то 
существенно, чтобы различные последовательности на рандомизированной ленте приводили 
к различному поведению.


Классы языков:

Язык L класса RP (“random polynomial” — случайные полиномиальные) допускается рандомизированной 
МТ M в следующем смысле:
    1. Если w не принадлежит L, то вероятность того, что M допускает w, равна 0.

    2. Если w принадлежит L, то вероятность того, что M допускает w, не меньше 1/2.

    3. Существует полином p(n), для которого, если w имеет длину n, то все вычисления M, 
    независимо от содержимого случайной ленты, останавливаются после не более p(n) шагов.

Класс языков, использующих рандомизацию, называется безошибочным вероятностным полиномиальным 
(zero-error, probabilistic, polynomial), или ZPP. Класс основан на рандомизированной МТ, 
которая всегда останавливается и имеет ожидаемое время останова, полиномиальное относительно 
длины входа. Эта МТ допускает свой вход, если попадает в допускающее состояние (и при этом 
останавливается), и отвергает его, останавливаясь без допускания. Таким образом, 
определение класса ZPP почти совпадает с определением класса P, за исключением того, что 
ZPP разрешает машине вести себя случайным образом, и ограничивается не время работы в худшем случае, а
ожидаемое время работы.

Замечание: Говорят, что машина Тьюринга M имеет временную сложность T(n) (или “время работы T(n)”), 
если, обрабатывая вход w длины n, M делает не более T(n) переходов и останавливается независимо 
от того, допущен вход или нет. Это определение применимо к любой функции T(n), например, 
T(n) = 50n^2 или T(n) = 3n + 5n^4. Нас будет интересовать, главным образом, случай, когда 
T(n) является полиномом относительно n. Мы говорим, что язык L принадлежит классу P, 
если существует полином T(n), при котором L = L(M) для некоторой детерминированной МТ M 
с временной сложностью T(n).
================================================================
Опиши алгоритм "перенос - свертка" в теории формальных языков
________________________________________________________________
Пусть G = (N, Σ, Р, S) — КС-грамматика,
правила которой занумерованы числами от 1 до р. Алгоритмом
типа „перенос—свертка" для грамматики G назовем пару функций 
A=((f, g)^s), где f называется функцией переноса, a g -
функцией свертки. Функции f и g определяются так:
    1) f отображает V^*x(Σ ∪ {$})^* в множество {перенос, свертка,
    ошибка, допуск}, где V = N ∪ Σ ∪ {$}, a $ — новый символ, концевой маркер.
    2) g отображает V^*x(Σ ∪ {$})^* в множество {1, 2, ..., р, ошибка} при условии, 
    что если g (α, ω) = i, то правая часть i-го правила является суффиксом цепочки α.

Алгоритм типа „перенос—свертка" использует входную ленту,
читаемую слева направо, и магазин. На основе того, что 
находится в магазине и осталось не обработанным на входе,
функция f решает, перенести ли текущий входной символ в магазин
или вызвать процедуру свертки. Если принимается последнее
из этих решений, то функция g решает, какую сделать свертку.

Работу алгоритма типа „перенос—свертка" можно
рассматривать в терминах конфигурацией, т. е. троек вида
    ($X1....Xm, a1...an$,p1...pr)
где
    A) $X1....Xm — содержимое магазина, причем Хm — верхний
    символ, Xi ∊ N∪Σ и $ служит маркером дна магазина,
    B) а1...аn — оставшаяся необработанной часть 
    первоначальной входной цепочки, а1—текущий входной символ, $ служит
    правым концевым маркером для входа,
    C) р1...рr — цепочка номеров правил, примененных при
    свертке первоначальной входной цепочки к цепочке Х1...Хm
    a1...an.

Один шаг алгоритма A можно описать с помощью двух
отношений ├─A^(s) и ├─A^(r) , определенных на конфигурациях (индекс A
в этих обозначениях будем опускать всюду, где можно):
    1) если f(α, aω) = перенос, то (α, aω, π)├─^(s)(αa, ω, π) для
    α ∊ V^*, ω ∊ (Σ ∪ {$})^* и π ∊ {1, ..., p}^*

    2) если f(αβ, ω) = свертка, g(αβ, ω) = i и А → β — правило
    с номером i, то (αβ, ω, π) ├─^(r) (αA, ω, πi),
    
    3) если f(α, ω) = допуск, то (α, ω, π)├─^(s) допуск,
    
    4) в остальных случаях (α, ω, π) ├─^(s) ошибка.

Определим отношение ├─ как объединение отношений ├─^(s) и  ├─^(r).
Отношения ├─^+ и |—^* определяются, как обычно.
Для ω ∊ Σ^* положим A(ω) = π, если ($, ω$, e) |—^* ($S, $, π)├─
допуск, и  A(ω) = ошибка, если такого π нет.
Будем называть алгоритм A корректным для грамматики G,
если
    A) L(G) = { ω |A(ω) != ошибка},
    B) π — правый разбор цепочки ω, если Л(ω) = π.

================================================================
Что такое грамматики расширенного предшествования в теории формальных языков
________________________________________________________________
Определение: Отношения предшествования Вирта—Вебера
<•, •= и •> для КС-грамматики G = (N, Σ, Р, S) определяются на
множестве N U Σ следующим образом:
    (1) Х<•У, если в Р есть такое правило A → αXBβ, что В => +Yy
    (2) X •= Y, если в Р есть правило A → αXYβ;
    (3) отношение •> определяется на (N U Σ)xΣ, так как
    непосредственно справа от основы в правовыводимой цепочке
    может быть только терминальный символ; полагаем Х•>а, если
    в P есть правило A → αBYβ, В => +Yy и Y=>*aδ (заметим,
    что Y=a, если Y=>°aδ).

Определение: Пусть G = (N, Σ, Р, S) — КС-грамматика и S =>r^(*) αAω =>r αβω =>r^(*) xω, где r 
является нижним индексом, — правый вывод в ней. Будем говорить, что правовыводимую цепочку αβω можно 
свернуть слева (или что она левосвертывается) к правовыводимой цепочке 
αAω с помощью правила A → β. Указанное вхождение цепочки β в цепочку αβω
назовем основой цепочки αβω. Таким образом, основа правовыводимой цепочки — это ее
любая подцепочка, которая является правой частью некоторого
правила, причем после замены ее левой частью этого правила
тоже получается правовыводимая цепочка.

Ключ к пониманию метода разбора по отношениям предшествования дает определение 
отношения •> между символами грамматики, которое при просмотре слева направо правовыводимой
цепочки αβω, где β — основа, впервые оказывается выполненным
для последнего символа цепочки β и первого символа цепочки ω.
Если для разбора применяется алгоритм типа „перенос — свертка", 
то всякий раз, когда между верхним символом магазина
и первым из необработанных входных символов выполняется
отношение •>, принимается решение о свертке; в противном
случае делается перенос.
Таким образом, с помощью отношения •> локализуется
правый конец основы правовыводимой цепочки. Локализация левого
конца основы и определение нужной свертки осуществляется
разными способами в зависимости от используемого типа 
предшествования.
Техника анализа, основанная на так называемом „простом
предшествовании", использует для выделения основы
правовыводимой цепочки αβω три отношения предшествования: <•, •=
и •>. Если β — основа, то между всеми смежными символами
цепочки α выполняется либо отношение <•, либо •=, между
последним символом цепочки α и первым символом цепочки β
выполняется <•, между смежными символами основы —
отношение •= и между последним символом цепочки β и первым 
символом цепочки ω — отношение •>.
Итак, основу правовыводимой цепочки грамматики простого
предшествования можно выделить, просматривая эту цепочку
слева направо до тех пор, пока впервые не встретится
отношение •>. Для нахождения левого конца основы надо возвращаться
назад, пока не встретится отношение <•. Цепочка, заключенная
между <• и •>, будет основой. Если грамматика предполагается
обратимой, то основу можно однозначно свернуть. Этот процесс
продолжается до тех пор, пока входная цепочка не свернется
к начальному символу (либо пока дальнейшие свертки окажутся
невозможными).

Определение: КС-грамматика G = (N, Σ, Р, S) называется
грамматикой предшествования, если она приведенная, не содержит
ε-правил и для любой пары символов из N U Σ выполняется не
более одного отношения предшествования Вирта — Вебера. Обратимая грамматика 
предшествования называется грамматикой простого предшествования.

Определение. Пусть G = (N, Σ, Р, S) — приведенная
КС-грамматика без ε-правил. Определим отношения (m,n)-предшествования <•, •= и •> 
на множестве (N U  Σ U {$})^(m) x (N U Σ U {$})^(n).
Пусть
    $^mS$^n =>r^(*) XpXp-1...Xp+1Aa1...aq, где в =>r^(*):  r - нижний индекс
            =>r XpXp-1...Xk+1Xk...X1a1...aq, где =>r: r - нижний индекс
— произвольный правый вывод. Тогда

    (1) а<•р, если α состоит из последних m символов цепочки
    XpXp-1 ... Xk+1 и либо
        (а) β состоит из первых n символов цепочки Хк...Х1а1...aq, ЛИбО
        (б) Хк - терминал и β ∊ FIRSTn(Хк...Х1a1...aq);
    (2) а •= р для всех таких к > j >= 1, что α состоит из
    последних n символов цепочки XpXp-1...Xj+i и либо
        (а) β состоит из первых n символов цепочки XjXj-1...Х1а1...aq либо
        (б) Xj — терминал и β ∊ FIRSTn(ХjХj-1...Х1а1...аn);
    (3) ХmХm-1...Х1 •> a1...an.

Будем говорить, что G—грамматика (m, n)-предшествования,
если G—приведенная КС-грамматика без ε-правил и отношения
<•, •= и •> попарно не пересекаются. Очевидно, что G — грамматика предшествования тогда и
только тогда, когда она — грамматика (1,1)-предшествования.
Детали, связанные с концевыми маркерами, легко восстанавливаются. 
При n=1 условия (1б) и (2б) не дают ничего нового.
================================================================
Что такое грамматики слабого предшествовования в теории формальных языков
________________________________________________________________
Определение. Пусть G = (N, Σ, Р, S) — приведенная КС-грамматика без ε-правил. 
Назовем G грамматикой слабого предшествования, если
    (1) отношение •> не пересекается с объединением отношений
    •= и <•
    (2) для А → αXβ и B → β из P, где не выполняется ни X<•,ни X•=B.

================================================================
Что такое грамматики операторного предшествования  в теории формальных языков
________________________________________________________________
Определение. Операторной грамматикой называется
приведенная КС-грамматика без ε-правил, в которой правые части
правил не содержат смежных нетерминалов.
Для операторной грамматики отношения предшествования
можно задать на множестве терминалов плюс символ $,
игнорируя нетерминалы. Пусть G=  (N, Σ, Р, S) — операторная
грамматика и $—новый символ. Зададим отношения операторного
предшествования на множестве Σ U {$}:
    (1) a•=b, если A → αaɣbβ ∊ P и ɣ ∊ (N U {e}),
    (2) a<•b, если А → αaBβ ∊ P и В =>^(+) ɣbδ, где ɣ ∊ (N U {e}),
    (3) а•>b, если A → aBh$?P и B =>^(+) δaɣ, где ɣ ∊ (N U {e}),
    (4) $<•a, если S =>^(+) ɣaα и ɣ ∊ (N U {e}),
    (5) a•>$, если S =>^(+) αab и ɣ ∊ (N U {e})

Операторная грамматика G называется грамматикой операторного
предшествования, если между любыми двумя терминальными символами 
выполняется не более одного отношения операторного предшествования.
================================================================
Что такое отношения предшествования Колмерауэра
________________________________________________________________
Определение: Пусть G = (N, Σ, Р, S) — КС-грамматика и <•,
•=, •> три непересекающихся отношения на N U Σ U {$}, где $ —
новый,символ (концевой маркер). Двухмагазинный анализатор,
индуцированный отношениями <•, •= и •>, определяется правилами
    (1) (X, У) → (ХК, е) тогда и только тогда, когда Х<•К или
    X•=Y,
    (2) (XZ1...Zk, Y) → (Х, Ay) тогда и только тогда, когда
    Zk•>Y, Zi •= Zi+i для 1<=i<k, X <• Z1 и A → Z1...Zk - правило грамматики G.
Заметим, что если G — обратимая грамматика, то
индуцированный двухмагазинный анализатор будет детерминированным,-
и обратно.

Определение. Пусть G — (N, Σ, Р, S) — КС-грамматика.
Назовем G грамматикой Колмерауэра, если
    (1) она однозначная,
    (2) приведенная,
    (3) существуют непересекающиеся отношения <•, •= и •> на
    N U Σ U {$}, индуцирующие двухмагазинный анализатор, корректный для G-
Эти отношения назовем отношениями предшествования
мерауэра. Заметим, что из условия (3) следует, что грамматика
Колмерауэра должна быть обратимой.
================================================================
Что такое рекурсивно перечислимый язык машины Тьюринга
________________________________________________________________
Пусть M = (Q, Σ, Γ, δ, q0, B, F) — машина Тьюринга. Тогда L(M)
представляет собой множество цепочек ω из Σ*, для которых q0ω ├─ αpβ при некотором
состоянии p из F и произвольных ленточных цепочках α и β. 
Языки, допустимые  с помощью машин Тьюринга, часто называются рекурсивно перечислимыми, или РП-языками. 
Термин “рекурсивно перечислимые” происходит от вычислительных формализмов, предшествовавших машинам Тьюринга,
но определявших тот же класс языков или арифметических функций.

Машины Тьюринга с односторонней лентой. МТ можно ограничить так, чтобы ее лента была бесконечной 
только справа и не имела клеток слева от начальной позиции головки. Такая МТ может допустить любой 
рекурсивно перечислимый язык.

Теорема: Каждый рекурсивно перечислимый язык допускается трехсчетчиковой
машиной Тьюринга.
Теорема: Каждый рекурсивно перечислимый язык допускается двухсчетчиковой
машиной Тьюринга.
================================================================
Опиши теорему Пиллинга в теории формальных языков
________________________________________________________________
Теорема Пиллинга (Pilling): Пусть существует некоторая КС-грамматика G = (N, Σ, Р, S).
Коммутативная конкатенация - переход к алгебре, где операция конкатенации является коммутативной.
Таким образом получается новый язык, но с таким же балансом букв (коммутативный образ).
Например: 
Пусть сущестуют следующие правила:
S → SbS
S → SSa
S → a
Тогда при переходе к коммутативной конкатенации и приведения подобных соответствующее правило для S 
будет выглядеть следующим образом: 
S → (a+b)S^(1)S+a
L(S) = ((a+b)a^(1))^(*)a = ((a+b)a)*a = (aa|ba)*a

Если после приведения подобных по коммутативной конкатенации имеем место быть правило:
Ni → φ1Ni^(k1)Ni+φ2Ni^(k2)Ni+...+φ(n-1)Ni^(kn-1)+φn, где φi не содержит Ni,
тогда коммутативный образ L(Ni) = (φ1φn^(k1)+φ2φn^(k2)+...+φn-1φn^(kn-1))^(*)φn.
================================================================
